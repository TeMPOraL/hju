#!/bin/sh
#|-*- mode:lisp -*-|#
#| hue cmdline controller
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp (ql:quickload '(cl-hue
                              apply-argv) :silent t)
  )

(defpackage :ros.script.hju.3690567483
  (:use :cl))
(in-package :ros.script.hju.3690567483)


;;; State.

(defvar *bridge* nil "Hue bridge.")
(defvar *all-lights* nil "All lights registered to the Hue bridge.")
(defvar *verbose* nil "Do a verbose output.")
(defvar *errno* 0 "Error return code to OS.")
(defvar *error-string* nil "Error string to show.")
(defvar *transition-time* 4 "Transition time (in 1/10ths of a second).")


;;; Help commands.

(defun print-usage ()
  (format t "~&hju - a simple command line controller for Hue lights
~&Version: 0.1
~&
~&Usage:
~&~8Thju [options...] <command> [args]"))

(defun print-help ()
  (print-usage)
  (format t "~%
~&Options:
~&~8T-h, --help~25,8@TDisplay this text.
~&~8T-v, --verbose~20,8@TMake output verbose.
~&~8T-b BRIDGE, --bridge=BRIDGE~10,8@TUse different bridge URL than the default.
~&~8T-u USER, --user=USER~15,8@TUse different user ID than the default.
~&~8T-t TRANSITION, --transition=TRANSITION~10,8@TUse specified transition time.
~&
~&~4TTRANSITION is given in seconds, can be fractional. Default value: 0.4.
~&
~&Defaults are taken from the config file .hju in your home directory.
~&The format of that file is:
~&~4T(:bridge \"bridge URL\" :user \"USER ID\")
~&
~&Commands:
~&~8Tstatus~20,8@TDisplay status of Hue bridge and all lights.
~&~8Tlist~25,8@TJust list available lights and their status.
~&~8Ton LIGHT~20,8@TTurn on LIGHT.
~&~8Toff LIGHT~20,8@TTurn off LIGHT.
~&~8Ttoggle LIGHT~15,8@TToggle LIGHT.
~&~8Treset LIGHT~15,8@TReset LIGHT to the values I (the author) like.
~&~8Tblink LIGHT~15,8@TBlink LIGHT.
~&~8Tset LIGHT rgb R G B~10,8@TSet color of LIGHT to rgb(R, G, B) (each component in [0...255]).
~&~8Tset LIGHT rgb #RRGGBB~10,8@TSet color of LIGHT to #RRGGBB (hex).
~&~8Tset LIGHT hsv H S V~10,8@TSet color of LIGHT to hsv(H, S, V) (each component in [0...255]).
~&~8Tset LIGHT bri BRI~10,8@TSet brightness of LIGHT to BRI [0...255].
~&~8Tset LIGHT ct CT~10,8@TSet color temperature of LIGHT to CT in Mired.
~&~8Tset LIGHT ctk CTK~10,8@TSet color temperature of LIGHT to CTK in Kelvins.
~&~8Tset LIGHT xy X Y~10,8@TSet color of LIGHT to coordinates (X, Y) in CIE color space.
~&
~&~4TLIGHT can be given as a number or as a prefix of its name.
"))


;;; Hue lights utils
(defun fetch-all-lights ()
  (setf *all-lights* (cl-hue:get-lights *bridge*)))


;;; Hue x Commands utils

(defun get-light-by-param-id (param-id)
  (let* ((numeric-id (parse-integer param-id :junk-allowed t))
         (light (if numeric-id
                    (find param-id *all-lights* :test #'string-equal :key #'cl-hue::light-number)
                    (find param-id *all-lights*
                          :test (lambda (key value)
                                  (let ((result (search key value :test #'char-equal)))
                                    (and (numberp result)
                                         (= 0 result))))
                          :key #'cl-hue::light-name))))
    (unless light
      (error "light ~A not found" param-id))
    light))

(defun light-short-description (light)
  (format nil "~A (~A)" (cl-hue::light-name light) (cl-hue::light-number light)))

(defun describe-light (light)
  (format t "~&[~A] ~A: ~A"
          (if (cl-hue::light-on-p light) "ON" "  ")
          (cl-hue::light-number light)
          (cl-hue::light-name light))
  (format t "~40TMode: ~A, HSV: (~A, ~A, ~A), Temp: ~A mireds."
          (cl-hue::light-colormode light)
          (cl-hue::light-hue light)
          (cl-hue::light-saturation light)
          (cl-hue::light-brightness light)
          (cl-hue::light-ct light)))

(defun describe-light-verbose (light)
  (format t "~&Light #~A: ~A" (cl-hue::light-number light) (cl-hue::light-name light))
  (format t "~&~4TState: ~A" (if (cl-hue::light-on-p light) "ON" "OFF"))
  (format t "~&~4TType: ~A" (cl-hue::light-type light))
  (format t "~&~4TModel ID: ~A" (cl-hue::light-modelid light))
  (format t "~&~4TUID: ~A" (cl-hue::light-uniqueid light))
  (format t "~&~4TSoftware version: ~A" (cl-hue::light-swversion light))
  (format t "~&~4TPoint symbol: ~A" (cl-hue::light-pointsymbol light))
  (format t "~&~4TReachable: ~A" (if (cl-hue::light-reachable-p light) "YES" "NO"))
  (format t "~&~4TColor mode: ~A" (cl-hue::light-colormode light))
  (format t "~&~8TBrightness: ~A" (cl-hue::light-brightness light))
  (format t "~&~8THue: ~A" (cl-hue::light-hue light))
  (format t "~&~8TSaturation: ~A" (cl-hue::light-saturation light))
  (format t "~&~8TXY: ~A" (cl-hue::light-xy light))
  (format t "~&~8TCT (Mired): ~A" (cl-hue::light-ct light))
  (format t "~%~%"))


;;; Actual commands
(defun bridge-status ()                        ;TODO
  (format t "STATUS: TODO."))

(defun list-lights ()
  (mapc (if *verbose*
            'describe-light-verbose
            'describe-light)
        *all-lights*))

(defun light-on (light)
  (when *verbose*
    (format t "~&Turning on ~A over ~A milliseconds..." (light-short-description light) (* 100 *transition-time*)))
  (cl-hue:set-light-state-by-number *bridge*
                                    (cl-hue::light-number light)
                                    :on t
                                    :transitiontime *transition-time*))

(defun light-off (light)
  ;; FIXME transition time is not used because it somehow breaks light settings...
  (declare (ignorable light))
  (when *verbose*
    (format t "~&Turning off ~A..." (light-short-description light)))
  (cl-hue:set-light-state-by-number *bridge*
                                    (cl-hue::light-number light)
                                    :on nil))

(defun light-toggle (light)
  (if (cl-hue::light-on-p light)
      (light-off light)
      (light-on light)))

(defun light-reset (light)
  (when *verbose*
    (format t "Resetting light ~A..." (light-short-description light)))
  (cl-hue::set-light-state-by-number *bridge* (cl-hue::light-number light)
                                     :on t
                                     :brightness 254
                                     :ct 233
                                     :transitiontime 2))

(defun light-blink (light)
  (declare (ignorable light))
  (when *verbose*
    (format t "Blinking light ~A..." (light-short-description light)))
  (cl-hue:set-light-state-by-number *bridge*
                                    (cl-hue::light-number light)
                                    :alert "select"))

(defun light-set-rgb (light r g b)            ;TODO
  (declare (ignorable light r g b))
  )

(defun light-set-rgb-hex (light hex-rgb)      ;TODO
  (declare (ignorable light hex-rgb))
  )

(defun light-set-hsv (light hsv)              ;TODO
  (declare (ignorable light hsv))
  )

(defun light-set-bri (light bri)        ;TODO
  (declare (ignorable light bri))
  )

(defun light-set-ct (light ct)          ;TODO
  (declare (ignorable light ct))
  )

(defun light-set-ctk (light ctk)        ;TODO
  (declare (ignorable light ctk))
  )

(defun light-set-xy (light x y)         ;TODO
  (declare (ignorable light x y))
  )


;;; Command selection utils.


;;; Error handling.

(defun errout (exit-code error-message)
  "Sets the error string to be displayed at the end of application to `ERROR-MESSAGE', and sets the exit value of the program to `EXIT-CODE'."
  (setf *errno* exit-code)
  (setf *error-string* error-message)
  nil)

(defun trap-errors-handler (error)
  (format *error-output* "Fatal error: ~A." error)
  (throw 'trap-errors -1))

(defmacro trap-errors (&rest forms)
  `(catch 'trap-errors
     (handler-bind ((error #'trap-errors-handler))
       ,@forms)))


;;; Entry point-related and command processing.

(defun init-hue-access (switches)
  ;; TODO also load from file
  (let ((bridge (or (getf switches :b)
                    (getf switches :bridge)))
        (user (or (getf switches :u)
                  (getf switches :user))))
    (if (and bridge user)
        (progn
          (setf *bridge* (cl-hue:make-bridge bridge user))
          (fetch-all-lights)
          t)
        (errout 1 "Bridge not set."))))

(defun run-set-command (light subverb args)
  ;; TODO
  )

(defun run-command (command switches)
  (declare (ignore switches))
  (let ((verb (first command))
        (args (rest command)))
    (cond
      ((string-equal verb "status")
       (bridge-status))
      ((string-equal verb "list")
       (list-lights))
      ((string-equal verb "on")
       (light-on (get-light-by-param-id (first args))))
      ((string-equal verb "off")
       (light-off (get-light-by-param-id (first args))))
      ((string-equal verb "toggle")
       (light-toggle (get-light-by-param-id (first args))))
      ((string-equal verb "reset")
       (light-reset (get-light-by-param-id (first args))))
      ((string-equal verb "blink")
       (light-blink (get-light-by-param-id (first args))))
      ((string-equal verb "set")
       (run-set-command (get-light-by-param-id (first args))
                        (second args)
                        (cddr args)))
)))

(defun execute (args)
  (trap-errors
   (let ((command (car (remove-if (lambda (p) (not (consp p))) args)))
         (switches (remove-if (lambda (p) (consp p)) args)))
     (format t "~S~%~S~%~S~%" args command switches) ;NOTE debug
     (let ((show-usage (null args))
           (show-help (or (getf switches :h) (getf switches :help)))
           (run-verbose (or (getf switches :v) (getf switches :verbose))))

       ;; Process switches.
       (when show-usage
         (print-usage)
         (return-from execute 1))

       (when show-help
         (print-help)
         (return-from execute 0))

       (when run-verbose
         (setf *verbose* t))

       ;; Init Hue connection and run actual command.
       (when (init-hue-access switches)
         (run-command command switches))

       ;; Display errors in init / command, if any.
       (when *error-string*
         (format t "~&ERROR: ~A~%" *error-string*)
         (return-from execute *errno*))))))

(defun main (&rest argv)
  (declare (ignorable argv))
  (execute (apply-argv:parse-argv argv)))

;;; vim: set ft=lisp lisp:
